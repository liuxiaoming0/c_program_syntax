# 知识点
完成比完美更重要

## 报错重复定义，头文件可以放什么？
链接：https://blog.csdn.net/weixin_42018112/article/details/82357002
变量和函数可以多次声明，但只能定义一次，因而头文件不能放定义，但有3个特殊：
1）const的全局变量；因为不会被默认extern；
2）inline内联函数；因为可以多次定义，只要定义展开都相同；
3）类函数的定义；

## extern、static全局变量的区别？
extern只能在.h声明，在.cpp定义，因为默认是全部源文件可见的。(extern) int t; 这里的extern没有是默认补全的。
static可以在.h中声明和定义，因为默认只对当前源文件可见。

## static作用？
局部静态变量：在作用外不会释放
类静态成员变量：多个类之间共享；类的静态/非静态成员函数都可访问；初始化？
类静态成员函数：只能访问类的静态成员变量

## inline函数
用法：标记在定义前，声明不需要，一般定义放在头文件
优势：消除调用函数的时间开销，但对内存系统（指令缓存）的性能可能降低
      进一步优化和改进调度，因为增加了函数体大小
      消除了调用函数的指令，参数放在堆栈，函数体、返回地址等
劣势：函数体副本多个，内存空间损失，生成的二进制文件更大
以下情况不宜使用内联：
    如果函数体内的代码比较长，使用内联将导致内存消耗代价较高
    如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大

## volatile
作用：关闭编译器优化，包括重新排序、合并访问，每次都要重新从寄存器（非ROM）取值。一般应用层不会用到，只有涉及汇编语言才用到
注意：无法防止CPU的重新排序，不排序内存（非 volatile 内存访问可以自由地重排到 volatile 访问前后）
      volatile 访问不是原子的（共时的读和写是数据竞争）
      在执行线程中，不能将通过volatile泛左值的访问（读和写）重排到同线程内先序于或后序于它的可观测副效应（包含其他 volatile 访问）后，但不保证另一线程观察到此顺序，因为 volatile 访问不建立线程间同步

## 指针&智能指针
问题：make_unique和new方式的区别，效率有差异吗？
问题：传参使用raw pointer 还是shared_ptr？
内存占用：int（4），raw pointer（8），unique_ptr(8), shared_ptr(16), weak_ptr(16)
unique_ptr
      [场景]作用域后自动销毁特性：避免析构忘记delete、避免异常退出对象未销毁
shared_ptr
      [性能]内存占用是裸指针2倍（维护裸指针和引用计数）、考虑线程安全问题，引用计数增减必须是原子操作，一般情况比非原子操作慢
           尽量使用移动，不增加引用计数，提高性能
      [场景]共享权不明：多对象管理同一内存。
            延迟销毁：对象析构耗时，影响关键链路，转给另一个线程释放。
      [相关]shared_from_this()、const shared_ptr
weak_ptr
      [场景]解决双向引用，weak_ptr不能单独创建，必须从shared_ptr复制，并保证先于shared_ptr释放，否则会出现使用nullptr

## constexpr
C：const语义只有“只读”
C++：const语义“只读”、“常量”，C11后建议常量用constexpr，只读用const

## tuple
来自STL库，与结构体、std::pair功能类似

## 完美转发
在模板时，将左右值属性完美传输

## 类相关virtual、explicit、default、delete、override、final、friend
- 类默认的成员函数：构造函数、析构函数、拷贝构造函数、拷贝赋值运算符、（移动构造函数？、移动拷贝构造函数？）
- 若自定义构造函数，编译器不会生成默认的析构函数，需要制定default
- delete显示删除成员函数
- override显示覆盖基类同名同参同返回值函数
- final类，不可继承；final虚函数，不可覆盖override
- 重载overload和覆盖override(重写)的区别
  重载要求函数名相同，但是参数列表必须不同；覆盖要求函数名、参数列表、返回值必须相同。
  重载描述的是同一个类中不同成员函数之间的关系；覆盖是子类和基类之间不同成员函数之间的关系。
  重载的确定是在编译时确定，是静态的；虚函数则是在运行时动态确定。
- friend类、friend类成员函数、friend全局函数
  都是可访问类的成员函数，只具有单向性
  friend属性不可继承
  friend成员函数要求两个类只能在一个.h文件里声明，并且friend类在另一个类的前面声明，在.cpp文件中定义。因而一般直接用friend类，而不用这种
### virtual
问题：虚函数表的原理？
构造函数不能虚函数，析构函数必须虚函数

### explicit 显示构造
只有单个参数需要执行显示构造，无参数或多参数不能用于执行隐式转换
只在类声明中使用关键字，定义时不需要





